"""
看的解答，利用桶排序。先找出nums中的最大值和最小值。然后申请n-1个桶，此时将最大值最小值从nums中去掉后，只有n-2数了，放在n-1个桶中，所以至少有一个
桶是空的，所以间距至少有一个桶的宽度。由于最大最小值在最后一个桶的最右侧和第一桶的最左侧，可以不纳入桶内。接下来，对每个桶都设置最大值和最小值，最大值
为float("-inf")，最小值为float("inf")，这样设置方便后面比较。下面就是设置桶的间距了，将最大值减去最小值然后除以n-1，并向上取整。下面遍历数组，
遇到最大值最小值跳过，计算应该放入的桶的下标，并与最大值比大，与最小值比小，最后就可以在每个桶内就可以确定桶内的最大值最小值。
下面就是计算最大间距，先将prev设为最小值，然后遍历桶（其实可以从第二个桶开始，因为第一个桶只有一个最小值），如果桶的没有数，跳过。接下来用每个桶的最小
值减去prev，与ret比较大小，接着，将桶内的最大值赋值给prev，遍历下一个桶。最后注意的是，将最大值减去prev，与ret比较。不然，遍历结束后，没有将最大值
纳入考虑范围。
"""
import math

class Solution:
    def maximumGap(self, nums):
        n = len(nums)
        if n < 2:
            return 0
        minNum = min(nums)
        maxNum = max(nums)
        print(minNum, maxNum)
        gap = math.ceil((maxNum - minNum) / (n - 1))
        print(gap)
        print(n)
        dumps = [[float("inf"), float("-inf")] for i in range(n-1)]
        for num in nums:
            if num == minNum or num == maxNum:
                continue
            idx = (num - minNum) // gap
            dumps[idx][0] = min(num, dumps[idx][0])
            dumps[idx][1] = max(num, dumps[idx][1])
        ret = float("-inf")
        prev = minNum
        for j in range(n-1):
            if dumps[j][0] == float("inf"):
                continue
            ret = max(ret, dumps[j][0] - prev)
            prev = dumps[j][1]
        return max(ret, maxNum-prev)


solve = Solution()
nums = [12115,10639,2351,29639,31300,11245,16323,24899,8043,4076,17583,15872,19443,12887,5286,6836,31052,25648,17584,24599,13787,24727,12414,5098,26096,23020,25338,28472,4345,25144,27939,10716,3830,13001,7960,8003,10797,5917,22386,12403,2335,32514,23767,1868,29882,31738,30157,7950,20176,11748,13003,13852,19656,25305,7830,3328,19092,28245,18635,5806,18915,31639,24247,32269,29079,24394,18031,9395,8569,11364,28701,32496,28203,4175,20889,28943,6495,14919,16441,4568,23111,20995,7401,30298,2636,16791,1662,27367,2563,22169,1607,15711,29277,32386,27365,31922,26142,8792]
print(solve.maximumGap(nums))