"""
这是一个典型的并查集题目，首先每个人各自成为一个朋友圈，所有开始总的朋友圈的数目为n（n为数组的长度）
问题的关键在与让同意朋友圈的人指向”共同的好友“,由于所给的二维数组是中心对称的，所以只要遍历
一半的数组，而且还避免了相同横纵坐标时的情况。如果某两个人是好友， 那么找出这两个人是否属于同一朋友圈，如果不是的话，
则让他们分别共同的好友成为好友，这样两人就是属于同一朋友圈了，为了后续计算的方便，可以进行路径压缩操作，此时由于两个朋友圈
合并，所以总的朋友圈的数目减一。
在找共同好友，也就是权限最高的朋友时，进行路径压缩。
我开始的算法少了分别去找不同人共同好友的步骤，但是最后返回结果的算法是对的，就是看数组中nums[i]==i的个数。
"""

class Solution:
    def findCircleNum(self, M):
        """
        :type M: List[List[int]]
        :rtype: int
        """
        n = len(M)
        ret = n
        nums = [i for i in range(n)]

        def find(i):       #  包含路径压缩，返回值为最终的目标，使新加入的”链表“头节点全部为该值
            if nums[i] != i:
                nums[i] =  find(nums[i])
            return nums[i]

        for i in range(n):
            for j in range(i+1, n):
                if M[i][j] == 1:
                    n1, n2 = find(i), find(j)
                    if n1 != n2:
                        nums[n2] = n1
                        ret -= 1
        return ret


solve = Solution()
# M = [[1,1,0],[1,1,0],[0,0,1]]
# M = [[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]
# M = [[1,1,0],[1,1,0],[0,0,1]]
M = [[1,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,1,1,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,1,0,0,0,0,1,0],[1,0,0,0,0,0,0,1,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,1,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,0,1,0,1,0,0,1],[0,0,0,0,1,1,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0,1,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,1]]
print(solve.findCircleNum(M))