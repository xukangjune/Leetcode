"""
本题主要考察数学基础。其实从000...000~999...999这期间1出现的次数是所有数字的总和的10分之1。这点知道就够了。计算位数可以先转化为字符串，
这样使用字符串的方法就好求多了。
在循环阶段，假设位2151，循环到2。由于2不是1，但是1在2之前出现，所以1在千位上出现过，千位上是1时，数字从1000~1999，共1000个，也就是ret += 10 ** (length - i - 1)
的意思。接下来，就是看千位上是2，百十个位上1出现的次数。比如1000，刚才是1在千位上出现的次数，现在要计算1【000】~1【999】，就是1在千位，百十个
位上1的次数，这就用到了概率的问题了。共有3个数，一共1000个，所以000~999数字统计是3000，而每一个数字的概率是相同的，为1/10，所以就是
ret += int(n[i]) * (length - i - 1) * 10 ** (length - i - 2)。
如果该位等于1，比如2151中百位的1，那么百位上1出现从（100~151），共52次，然后同样使用
ret += int(n[i]) * (length - i - 1) * 10 ** (length - i - 2)在百位固定，十个位中1出现的次数，利用概率。
这个算法，有一点需要注意的是，因为每次都是将一位固定，然后对剩下的各位进行操作，但是假如输入的是一个个位数，就不能进行上述操作，所以开始循环的范围
只到length-1。而在之前判断判断个位数是否大于0，如果大于0，就直接加1。
算法的核心，就是相当于剥洋葱一样，每次都会将最高位剥离，每次都会将最高位存在时（不能等于0），出现1的个数
"""
class Solution(object):
    def countDigitOne(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 太慢了
        # 算了，也还行吧
        ret = 0
        if n <= 0:
            return ret
        n = str(n)
        length = len(n)
        if n[length-1] > '0':
            ret += 1
        for i in range(length-1):
            if n[i] > '1':
                ret += 10 ** (length - i - 1)
                ret += int(n[i]) * (length - i - 1) * 10 ** (length - i - 2)
            elif n[i] == '1':
                ret += int(n[i+1:])+1
                ret += (length - i - 1) * 10 ** (length - i - 2)
        return ret


solve = Solution()
print(solve.countDigitOne(110))